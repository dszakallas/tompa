#![macro_use]

use super::types::*;

// Note: This, as most macros in this crate are written in continuation passing style
// which enables us to reuse it in other macros. See https://danielkeep.github.io/tlborm/book/pat-callbacks.html
macro_rules! instruction_defs_cps { ($cb:ident($($args:tt)*)) => { $cb!{
$($args)*
/*
                    Parameters              Text                Opcode                   Parsing              Typing rule
*/
Unreachable			 { params: (), text: "unreachable",			 opcode: 0x00i32,			 parse: NoArg(),			 check: UnreachableType {} },
Nop			 { params: (), text: "nop",			 opcode: 0x01i32,			 parse: NoArg(),			 check: NopType { } },
Block			 { params: (result: Option<ValType>, instrs: Vec<Instruction>), text: "block",			 opcode: 0x02i32,			 parse: Block(),			 check: BlockType {} },
Loop             { params: (result: Option<ValType>, instrs: Vec<Instruction>), text: "loop", opcode: 0x03i32,  parse: Loop(),			 check: LoopType {} },
If			     { params: (result: Option<ValType>, if_instrs: Vec<Instruction>, else_instrs: Vec<Instruction>), text: "if",			 opcode: 0x04i32,			 parse: If(),			 check: IfType {} },
Br			     { params: (), text: "br",			 opcode: 0x0ci32,			 parse: NoArg(),			 check: BrType {} },
BrIf			 { params: (), text: "br_if",			 opcode: 0x0di32,			 parse: NoArg(),			 check: BrIfType {} },
BrTable			 { params: (), text: "br_table",			 opcode: 0x0ei32,			 parse: NoArg(),			 check: BrTableType {} },
Return			 { params: (), text: "return",			 opcode: 0x0fi32,			 parse: NoArg(),			 check: ReturnType{} },
Call			 { params: (), text: "call",			 opcode: 0x10i32,			 parse: NoArg(),			 check: CallType{} },
CallIndirect     { params: (), text: "call_indirect",			 opcode: 0x11i32,			 parse: NoArg(),			 check: CallIndirectType{} },
Drop			 { params: (), text: "drop",			 opcode: 0x1ai32,			 parse: NoArg(),			 check: () },
Select			 { params: (), text: "select",			 opcode: 0x1bi32,			 parse: NoArg(),			 check: () },
LocalGet			 { params: (localidx: LocalIdx), text: "local.get",			 opcode: 0x20i32,			 parse: LocalIdx(),			 check: () },
LocalSet			 { params: (localidx: LocalIdx), text: "local.set",			 opcode: 0x21i32,			 parse: LocalIdx(),			 check: () },
LocalTee			 { params: (localidx: LocalIdx), text: "local.tee",			 opcode: 0x22i32,			 parse: LocalIdx(),			 check: () },
GlobalGet			 { params: (globalidx: GlobalIdx), text: "global.get",			 opcode: 0x23i32,			 parse: GlobalIdx(),			 check: () },
GlobalSet			 { params: (globalidx: GlobalIdx), text: "global.set",			 opcode: 0x24i32,			 parse: GlobalIdx(),			 check: () },
I32Load             { params: (memarg: Memarg), text: "i32.load",			 opcode: 0x28i32,			 parse: MemLs(4),                     check: LoadType { valtype: ValType::I32, storage: None } },
I64Load			    { params: (memarg: Memarg), text: "i64.load",			 opcode: 0x29i32,			 parse: MemLs(8),			            check: LoadType { valtype: ValType::I64, storage: None } },
F32Load			    { params: (memarg: Memarg), text: "f32.load",			 opcode: 0x2ai32,			 parse: MemLs(4),			            check: LoadType { valtype: ValType::F32, storage: None } },
F64Load			    { params: (memarg: Memarg), text: "f64.load",			 opcode: 0x2bi32,			 parse: MemLs(8),			            check: LoadType { valtype: ValType::F64, storage: None } },
I32Load8S			{ params: (memarg: Memarg), text: "i32.load8_s",			 opcode: 0x2ci32,			 parse: MemLs(1),			        check: LoadType { valtype: ValType::I32, storage: Some((1, Sx::S)) } },
I32Load8U			{ params: (memarg: Memarg), text: "i32.load8_u",			 opcode: 0x2di32,			 parse: MemLs(1),			        check: LoadType { valtype: ValType::I32, storage: Some((1, Sx::U)) } },
I32Load16S			{ params: (memarg: Memarg), text: "i32.load16_s",			 opcode: 0x2ei32,			 parse: MemLs(2),			        check: LoadType { valtype: ValType::I32, storage: Some((2, Sx::S)) } },
I32Load16U			{ params: (memarg: Memarg), text: "i32.load16_u",			 opcode: 0x2fi32,			 parse: MemLs(2),			        check: LoadType { valtype: ValType::I32, storage: Some((2, Sx::U)) } },
I64Load8S			{ params: (memarg: Memarg), text: "i64.load8_s",			 opcode: 0x30i32,			 parse: MemLs(1),			        check: LoadType { valtype: ValType::I64, storage: Some((1, Sx::S)) } },
I64Load8U			{ params: (memarg: Memarg), text: "i64.load8_u",			 opcode: 0x31i32,			 parse: MemLs(1),			        check: LoadType { valtype: ValType::I64, storage: Some((1, Sx::U)) } },
I64Load16S			{ params: (memarg: Memarg), text: "i64.load16_s",			 opcode: 0x32i32,			 parse: MemLs(2),			        check: LoadType { valtype: ValType::I64, storage: Some((2, Sx::S)) } },
I64Load16U			{ params: (memarg: Memarg), text: "i64.load16_u",			 opcode: 0x33i32,			 parse: MemLs(2),			        check: LoadType { valtype: ValType::I64, storage: Some((3, Sx::U)) } },
I64Load32S			{ params: (memarg: Memarg), text: "i64.load32_s",			 opcode: 0x34i32,			 parse: MemLs(4),			        check: LoadType { valtype: ValType::I64, storage: Some((4, Sx::S)) } },
I64Load32U			{ params: (memarg: Memarg), text: "i64.load32_u",			 opcode: 0x35i32,			 parse: MemLs(4),			        check: LoadType { valtype: ValType::I64, storage: Some((4, Sx::U)) } },
I32Store			{ params: (memarg: Memarg), text: "i32.store",			 opcode: 0x36i32,			 parse: MemLs(4),			        check: StoreType { valtype: ValType::I32, storage: None } },
I64Store			{ params: (memarg: Memarg), text: "i64.store",			 opcode: 0x37i32,			 parse: MemLs(8),			        check: StoreType { valtype: ValType::I64, storage: None } },
F32Store			{ params: (memarg: Memarg), text: "f32.store",			 opcode: 0x38i32,			 parse: MemLs(4),			        check: StoreType { valtype: ValType::F32, storage: None } },
F64Store			{ params: (memarg: Memarg), text: "f64.store",			 opcode: 0x39i32,			 parse: MemLs(8),			        check: StoreType { valtype: ValType::F64, storage: None } },
I32Store8			{ params: (memarg: Memarg), text: "i32.store8",			 opcode: 0x3ai32,			 parse: MemLs(1),			        check: StoreType { valtype: ValType::I32, storage: Some(1) } },
I32Store16			{ params: (memarg: Memarg), text: "i32.store16",			 opcode: 0x3bi32,			 parse: MemLs(2),			        check: StoreType { valtype: ValType::I32, storage: Some(2) } },
I64Store8			{ params: (memarg: Memarg), text: "i64.store8",			 opcode: 0x3ci32,			 parse: MemLs(1),			        check: StoreType { valtype: ValType::I64, storage: Some(1) } },
I64Store16			{ params: (memarg: Memarg), text: "i64.store16",			 opcode: 0x3di32,			 parse: MemLs(2),			        check: StoreType { valtype: ValType::I64, storage: Some(2) } },
I64Store32			{ params: (memarg: Memarg), text: "i64.store32",			 opcode: 0x3ei32,			 parse: MemLs(4),			        check: StoreType { valtype: ValType::I64, storage: Some(4) } },
MemorySize			 { params: (), text: "memory.size",			 opcode: 0x3fi32,			 parse: NoArg(),			 check: () },
MemoryGrow			 { params: (), text: "memory.grow",			 opcode: 0x40i32,			 parse: NoArg(),			 check: () },
I32Const			 { params: (param: u32), text: "i32.const",			 opcode: 0x41i32,			 parse: ConstI32(),			 check: () },
I64Const			 { params: (param: u64), text: "i64.const",			 opcode: 0x42i32,			 parse: ConstI64(),			 check: () },
F32Const			 { params: (param: f32), text: "f32.const",			 opcode: 0x43i32,			 parse: ConstF32(),			 check: () },
F64Const			 { params: (param: f64), text: "f64.const",			 opcode: 0x44i32,			 parse: ConstF64(),			 check: () },
I32Eqz			 { params: (), text: "i32.eqz",			 opcode: 0x45i32,			 parse: NoArg(),			 check: () },
I32Eq			 { params: (), text: "i32.eq",			 opcode: 0x46i32,			 parse: NoArg(),			 check: () },
I32Ne			 { params: (), text: "i32.ne",			 opcode: 0x47i32,			 parse: NoArg(),			 check: () },
I32LtS			 { params: (), text: "i32.lt_s",			 opcode: 0x48i32,			 parse: NoArg(),			 check: () },
I32LtU			 { params: (), text: "i32.lt_u",			 opcode: 0x49i32,			 parse: NoArg(),			 check: () },
I32GtS			 { params: (), text: "i32.gt_s",			 opcode: 0x4ai32,			 parse: NoArg(),			 check: () },
I32GtU			 { params: (), text: "i32.gt_u",			 opcode: 0x4bi32,			 parse: NoArg(),			 check: () },
I32LeS			 { params: (), text: "i32.le_s",			 opcode: 0x4ci32,			 parse: NoArg(),			 check: () },
I32LeU			 { params: (), text: "i32.le_u",			 opcode: 0x4di32,			 parse: NoArg(),			 check: () },
I32GeS			 { params: (), text: "i32.ge_s",			 opcode: 0x4ei32,			 parse: NoArg(),			 check: () },
I32GeU			 { params: (), text: "i32.ge_u",			 opcode: 0x4fi32,			 parse: NoArg(),			 check: () },
I64Eqz			 { params: (), text: "i64.eqz",			 opcode: 0x50i32,			 parse: NoArg(),			 check: () },
I64Eq			 { params: (), text: "i64.eq",			 opcode: 0x51i32,			 parse: NoArg(),			 check: () },
I64Ne			 { params: (), text: "i64.ne",			 opcode: 0x52i32,			 parse: NoArg(),			 check: () },
I64LtS			 { params: (), text: "i64.lt_s",			 opcode: 0x53i32,			 parse: NoArg(),			 check: () },
I64LtU			 { params: (), text: "i64.lt_u",			 opcode: 0x54i32,			 parse: NoArg(),			 check: () },
I64GtS			 { params: (), text: "i64.gt_s",			 opcode: 0x55i32,			 parse: NoArg(),			 check: () },
I64GtU			 { params: (), text: "i64.gt_u",			 opcode: 0x56i32,			 parse: NoArg(),			 check: () },
I64LeS			 { params: (), text: "i64.le_s",			 opcode: 0x57i32,			 parse: NoArg(),			 check: () },
I64LeU			 { params: (), text: "i64.le_u",			 opcode: 0x58i32,			 parse: NoArg(),			 check: () },
I64GeS			 { params: (), text: "i64.ge_s",			 opcode: 0x59i32,			 parse: NoArg(),			 check: () },
I64GeU			 { params: (), text: "i64.ge_u",			 opcode: 0x5ai32,			 parse: NoArg(),			 check: () },
F32Eq			 { params: (), text: "f32.eq",			 opcode: 0x5bi32,			 parse: NoArg(),			 check: () },
F32Ne			 { params: (), text: "f32.ne",			 opcode: 0x5ci32,			 parse: NoArg(),			 check: () },
F32Lt			 { params: (), text: "f32.lt",			 opcode: 0x5di32,			 parse: NoArg(),			 check: () },
F32Gt			 { params: (), text: "f32.gt",			 opcode: 0x5ei32,			 parse: NoArg(),			 check: () },
F32Le			 { params: (), text: "f32.le",			 opcode: 0x5fi32,			 parse: NoArg(),			 check: () },
F32Ge			 { params: (), text: "f32.ge",			 opcode: 0x60i32,			 parse: NoArg(),			 check: () },
F64Eq			 { params: (), text: "f64.eq",			 opcode: 0x61i32,			 parse: NoArg(),			 check: () },
F64Ne			 { params: (), text: "f64.ne",			 opcode: 0x62i32,			 parse: NoArg(),			 check: () },
F64Lt			 { params: (), text: "f64.lt",			 opcode: 0x63i32,			 parse: NoArg(),			 check: () },
F64Gt			 { params: (), text: "f64.gt",			 opcode: 0x64i32,			 parse: NoArg(),			 check: () },
F64Le			 { params: (), text: "f64.le",			 opcode: 0x65i32,			 parse: NoArg(),			 check: () },
F64Ge			 { params: (), text: "f64.ge",			 opcode: 0x66i32,			 parse: NoArg(),			 check: () },
I32Clz			 { params: (), text: "i32.clz",			 opcode: 0x67i32,			 parse: NoArg(),			 check: () },
I32Ctz			 { params: (), text: "i32.ctz",			 opcode: 0x68i32,			 parse: NoArg(),			 check: () },
I32Popcnt			 { params: (), text: "i32.popcnt",			 opcode: 0x69i32,			 parse: NoArg(),			 check: () },
I32Add			 { params: (), text: "i32.add",			 opcode: 0x6ai32,			 parse: NoArg(),			 check: () },
I32Sub			 { params: (), text: "i32.sub",			 opcode: 0x6bi32,			 parse: NoArg(),			 check: () },
I32Mul			 { params: (), text: "i32.mul",			 opcode: 0x6ci32,			 parse: NoArg(),			 check: () },
I32DivS			 { params: (), text: "i32.div_s",			 opcode: 0x6di32,			 parse: NoArg(),			 check: () },
I32DivU			 { params: (), text: "i32.div_u",			 opcode: 0x6ei32,			 parse: NoArg(),			 check: () },
I32RemS			 { params: (), text: "i32.rem_s",			 opcode: 0x6fi32,			 parse: NoArg(),			 check: () },
I32RemU			 { params: (), text: "i32.rem_u",			 opcode: 0x70i32,			 parse: NoArg(),			 check: () },
I32And			 { params: (), text: "i32.and",			 opcode: 0x71i32,			 parse: NoArg(),			 check: () },
I32Or			 { params: (), text: "i32.or",			 opcode: 0x72i32,			 parse: NoArg(),			 check: () },
I32Xor			 { params: (), text: "i32.xor",			 opcode: 0x73i32,			 parse: NoArg(),			 check: () },
I32Shl			 { params: (), text: "i32.shl",			 opcode: 0x74i32,			 parse: NoArg(),			 check: () },
I32ShrS			 { params: (), text: "i32.shr_s",			 opcode: 0x75i32,			 parse: NoArg(),			 check: () },
I32ShrU			 { params: (), text: "i32.shr_u",			 opcode: 0x76i32,			 parse: NoArg(),			 check: () },
I32Rotl			 { params: (), text: "i32.rotl",			 opcode: 0x77i32,			 parse: NoArg(),			 check: () },
I32Rotr			 { params: (), text: "i32.rotr",			 opcode: 0x78i32,			 parse: NoArg(),			 check: () },
I64Clz			 { params: (), text: "i64.clz",			 opcode: 0x79i32,			 parse: NoArg(),			 check: () },
I64Ctz			 { params: (), text: "i64.ctz",			 opcode: 0x7ai32,			 parse: NoArg(),			 check: () },
I64Popcnt			 { params: (), text: "i64.popcnt",			 opcode: 0x7bi32,			 parse: NoArg(),			 check: () },
I64Add			 { params: (), text: "i64.add",			 opcode: 0x7ci32,			 parse: NoArg(),			 check: () },
I64Sub			 { params: (), text: "i64.sub",			 opcode: 0x7di32,			 parse: NoArg(),			 check: () },
I64Mul			 { params: (), text: "i64.mul",			 opcode: 0x7ei32,			 parse: NoArg(),			 check: () },
I64DivS			 { params: (), text: "i64.div_s",			 opcode: 0x7fi32,			 parse: NoArg(),			 check: () },
I64DivU			 { params: (), text: "i64.div_u",			 opcode: 0x80i32,			 parse: NoArg(),			 check: () },
I64RemS			 { params: (), text: "i64.rem_s",			 opcode: 0x81i32,			 parse: NoArg(),			 check: () },
I64RemU			 { params: (), text: "i64.rem_u",			 opcode: 0x82i32,			 parse: NoArg(),			 check: () },
I64And			 { params: (), text: "i64.and",			 opcode: 0x83i32,			 parse: NoArg(),			 check: () },
I64Or			 { params: (), text: "i64.or",			 opcode: 0x84i32,			 parse: NoArg(),			 check: () },
I64Xor			 { params: (), text: "i64.xor",			 opcode: 0x85i32,			 parse: NoArg(),			 check: () },
I64Shl			 { params: (), text: "i64.shl",			 opcode: 0x86i32,			 parse: NoArg(),			 check: () },
I64ShrS			 { params: (), text: "i64.shr_s",			 opcode: 0x87i32,			 parse: NoArg(),			 check: () },
I64ShrU			 { params: (), text: "i64.shr_u",			 opcode: 0x88i32,			 parse: NoArg(),			 check: () },
I64Rotl			 { params: (), text: "i64.rotl",			 opcode: 0x89i32,			 parse: NoArg(),			 check: () },
I64Rotr			 { params: (), text: "i64.rotr",			 opcode: 0x8ai32,			 parse: NoArg(),			 check: () },
F32Abs			 { params: (), text: "f32.abs",			 opcode: 0x8bi32,			 parse: NoArg(),			 check: () },
F32Neg			 { params: (), text: "f32.neg",			 opcode: 0x8ci32,			 parse: NoArg(),			 check: () },
F32Ceil			 { params: (), text: "f32.ceil",			 opcode: 0x8di32,			 parse: NoArg(),			 check: () },
F32Floor			 { params: (), text: "f32.floor",			 opcode: 0x8ei32,			 parse: NoArg(),			 check: () },
F32Trunc			 { params: (), text: "f32.trunc",			 opcode: 0x8fi32,			 parse: NoArg(),			 check: () },
F32Nearest			 { params: (), text: "f32.nearest",			 opcode: 0x90i32,			 parse: NoArg(),			 check: () },
F32Sqrt			 { params: (), text: "f32.sqrt",			 opcode: 0x91i32,			 parse: NoArg(),			 check: () },
F32Add			 { params: (), text: "f32.add",			 opcode: 0x92i32,			 parse: NoArg(),			 check: () },
F32Sub			 { params: (), text: "f32.sub",			 opcode: 0x93i32,			 parse: NoArg(),			 check: () },
F32Mul			 { params: (), text: "f32.mul",			 opcode: 0x94i32,			 parse: NoArg(),			 check: () },
F32Div			 { params: (), text: "f32.div",			 opcode: 0x95i32,			 parse: NoArg(),			 check: () },
F32Min			 { params: (), text: "f32.min",			 opcode: 0x96i32,			 parse: NoArg(),			 check: () },
F32Max			 { params: (), text: "f32.max",			 opcode: 0x97i32,			 parse: NoArg(),			 check: () },
F32Copysign			 { params: (), text: "f32.copysign",			 opcode: 0x98i32,			 parse: NoArg(),			 check: () },
F64Abs			 { params: (), text: "f64.abs",			 opcode: 0x99i32,			 parse: NoArg(),			 check: () },
F64Neg			 { params: (), text: "f64.neg",			 opcode: 0x9ai32,			 parse: NoArg(),			 check: () },
F64Ceil			 { params: (), text: "f64.ceil",			 opcode: 0x9bi32,			 parse: NoArg(),			 check: () },
F64Floor			 { params: (), text: "f64.floor",			 opcode: 0x9ci32,			 parse: NoArg(),			 check: () },
F64Trunc			 { params: (), text: "f64.trunc",			 opcode: 0x9di32,			 parse: NoArg(),			 check: () },
F64Nearest			 { params: (), text: "f64.nearest",			 opcode: 0x9ei32,			 parse: NoArg(),			 check: () },
F64Sqrt			 { params: (), text: "f64.sqrt",			 opcode: 0x9fi32,			 parse: NoArg(),			 check: () },
F64Add			 { params: (), text: "f64.add",			 opcode: 0xa0i32,			 parse: NoArg(),			 check: () },
F64Sub			 { params: (), text: "f64.sub",			 opcode: 0xa1i32,			 parse: NoArg(),			 check: () },
F64Mul			 { params: (), text: "f64.mul",			 opcode: 0xa2i32,			 parse: NoArg(),			 check: () },
F64Div			 { params: (), text: "f64.div",			 opcode: 0xa3i32,			 parse: NoArg(),			 check: () },
F64Min			 { params: (), text: "f64.min",			 opcode: 0xa4i32,			 parse: NoArg(),			 check: () },
F64Max			 { params: (), text: "f64.max",			 opcode: 0xa5i32,			 parse: NoArg(),			 check: () },
F64Copysign			 { params: (), text: "f64.copysign",			 opcode: 0xa6i32,			 parse: NoArg(),			 check: () },
I32WrapI64			 { params: (), text: "i32.wrap_i64",			 opcode: 0xa7i32,			 parse: NoArg(),			 check: () },
I32TruncF32S			 { params: (), text: "i32.trunc_f32_s",			 opcode: 0xa8i32,			 parse: NoArg(),			 check: () },
I32TruncF32U			 { params: (), text: "i32.trunc_f32_u",			 opcode: 0xa9i32,			 parse: NoArg(),			 check: () },
I32TruncF64S			 { params: (), text: "i32.trunc_f64_s",			 opcode: 0xaai32,			 parse: NoArg(),			 check: () },
I32TruncF64U			 { params: (), text: "i32.trunc_f64_u",			 opcode: 0xabi32,			 parse: NoArg(),			 check: () },
I64ExtendI32S			 { params: (), text: "i64.extend_i32_s",			 opcode: 0xaci32,			 parse: NoArg(),			 check: () },
I64ExtendI32U			 { params: (), text: "i64.extend_i32_u",			 opcode: 0xadi32,			 parse: NoArg(),			 check: () },
I64TruncF32S			 { params: (), text: "i64.trunc_f32_s",			 opcode: 0xaei32,			 parse: NoArg(),			 check: () },
I64TruncF32U			 { params: (), text: "i64.trunc_f32_u",			 opcode: 0xafi32,			 parse: NoArg(),			 check: () },
I64TruncF64S			 { params: (), text: "i64.trunc_f64_s",			 opcode: 0xb0i32,			 parse: NoArg(),			 check: () },
I64TruncF64U			 { params: (), text: "i64.trunc_f64_u",			 opcode: 0xb1i32,			 parse: NoArg(),			 check: () },
F32ConvertI32S			 { params: (), text: "f32.convert_i32_s",			 opcode: 0xb2i32,			 parse: NoArg(),			 check: () },
F32ConvertI32U			 { params: (), text: "f32.convert_i32_u",			 opcode: 0xb3i32,			 parse: NoArg(),			 check: () },
F32ConvertI64S			 { params: (), text: "f32.convert_i64_s",			 opcode: 0xb4i32,			 parse: NoArg(),			 check: () },
F32ConvertI64U			 { params: (), text: "f32.convert_i64_u",			 opcode: 0xb5i32,			 parse: NoArg(),			 check: () },
F32DemoteF64			 { params: (), text: "f32.demote_f64",			 opcode: 0xb6i32,			 parse: NoArg(),			 check: () },
F64ConvertI32S			 { params: (), text: "f64.convert_i32_s",			 opcode: 0xb7i32,			 parse: NoArg(),			 check: () },
F64ConvertI32U			 { params: (), text: "f64.convert_i32_u",			 opcode: 0xb8i32,			 parse: NoArg(),			 check: () },
F64ConvertI64S			 { params: (), text: "f64.convert_i64_s",			 opcode: 0xb9i32,			 parse: NoArg(),			 check: () },
F64ConvertI64U			 { params: (), text: "f64.convert_i64_u",			 opcode: 0xbai32,			 parse: NoArg(),			 check: () },
F64PromoteF32			 { params: (), text: "f64.promote_f32",			 opcode: 0xbbi32,			 parse: NoArg(),			 check: () },
I32ReinterpretF32			 { params: (), text: "i32.reinterpret_f32",			 opcode: 0xbci32,			 parse: NoArg(),			 check: () },
I64ReinterpretF64			 { params: (), text: "i64.reinterpret_f64",			 opcode: 0xbdi32,			 parse: NoArg(),			 check: () },
F32ReinterpretI32			 { params: (), text: "f32.reinterpret_i32",			 opcode: 0xbei32,			 parse: NoArg(),			 check: () },
F64ReinterpretI64			 { params: (), text: "f64.reinterpret_i64",			 opcode: 0xbfi32,			 parse: NoArg(),			 check: () }
}};
}

macro_rules! def_instructions {
    ($($id:ident { params: ($($arg_key:ident: $arg_tpe:ty),*), $($_rest:tt)* }),*) => {
        $(
            #[derive(Clone, Debug, PartialEq)]
            pub struct $id {
                $(pub $arg_key: $arg_tpe),*
            }
        )*
    }
}

macro_rules! def_instructions_enum {
    ($($id:ident {$($body:tt)*}),*) => {
        #[derive(Clone, Debug, PartialEq)]
        pub enum Instruction {
            $($id($id)),*
        }
    };
}

instruction_defs_cps!(def_instructions());

instruction_defs_cps!(def_instructions_enum());

